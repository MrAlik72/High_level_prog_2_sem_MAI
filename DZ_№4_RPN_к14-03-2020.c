#include <stdio.h>
#include <string.h>
#define STACK_SIZE 10// Фиксированный размер стека (лол, ..., какое динамическое выделение памяти)
//Ich Liebe Deutsch. Warum habe ich kein Englisch gelernt?
typedef struct stack{
    int st[STACK_SIZE]; // Типо сам стек
    int count;// Количество элементов в стеке
}stack;// Заявляю, что stack это тип данных структуры стека


void init_stack(stack *s){// Ну типо инициализация стека
    s->count=0;
}

int pop(stack *s){// ПОП  (pop от англ-выскочить) забирается из стека
    if(s->count>0){//если элементов в стеке нет, что оттуда можно вытащить??? МУСООООООР
    `
        s->count--;// Ого,понижается колчиство элементов в стеке 
        return s->st[s->count]; // функция возвращает последний добавленный элемент
    }
    else{
        printf("Pustoi stack\n");`
        return 2;
    }
}
int push(int value, stack *s){// ПУШ  (push от англ положить) фигачим в стек 
    if (s->count<STACK_SIZE){// Если в стеке оказалось меньше элементов чем БЫЛО зафиксировано, то можно продолжить 
        s->st[s->count]=value;/* Типо такие все весёлые от того что там меньше элементов и можно запихнуть в стек значение, 
    которое передалось функции push первым аргументом 
    из структуры s берется элемент st, который  является массивом, а массиву говорим,мол на тебе 
    в элемент с индексом count  значение value (value с англ-значение)*/
        s->count++;// на 1 элемент в стеке стало больше
    }
    else{
        printf("Perepolnen stack\n");// Если вдруг в стеке оказалось больше элементов чем было зафиксировано, то остается плакать
        return 1;
    }
}

void add(stack *s){// ЭДД (add  от англ добавить/сложить )  сложение элементов стека
    if(s->count>1){// Если в стеке больше 1 элемента
        int a=pop(s);// То добавка в стек последние 2 элемента из стека 
        int b=pop(s);
        push((a+b), s);//(при этом эти два элемента исчезают)
    }
    else{
        printf("Nehvatilo symbolov\n");
    }   
}

void substract(stack *s){// САБСТРАКТ  (substract от англ вычесть ) 
    if(s->count>1){
        int a=pop(s);// тут переменные отдельные, так как извлекается из стека в обратном порядке
        int b=pop(s);
        push((b-a), s);
    }
    else{
        printf("Nehvatilo symbolov\n");
    }
}

void multiply(stack *s){// МУЛЬТИПЛАЙ (multiply от англ умножить)
    if(s->count>1){
        int a = pop(s);
        int b = pop(s);
        push((a*b), s);
    }
    else{
        printf("Nehvatilo symbolov\n");
    } 
}

void divide(stack *s){// ДИВАЙД  (делить-от буржуйского)
    if(s->count>1){
        int a = pop(s);// Тут опять делиться в прямом порядке, а извлекается в обратном, поэтому нужно где-то временно хранить переменные
        int b = pop(s);
        if (a == 0){// сложно
            printf("Na nulik delit nelza\n");//Кроме Коши, Коши можно , ему все можно
        }
        else{
            push((b/a), s);
        }
    }
    else{
        printf("Nehvatilo symbolov\n");
    }  
}

int main() {
    stack s;// Объявляение, что s это переменная типа данных структуры стека
    init_stack(&s); // Инициализация стека
    char *str = "94+8*"; // Создание указателя, который указывает на 1 элемент строки ,которая после равно
    int ch = 0; // Создание переменной, в которую далее будем класть то число(или знак), на которое указывает указатель
    int  i = 0;


    for(; i<strlen(str); i++){ //  цикл, с помощью которого можно пробежатся по всей строке
        ch = str[i]; // Каждую следующую иттерацию цикла кладём в ch следующий элемент строки 
        if ((ch > '0') && (ch < '9')){// Если в ch оказалось число
            push(ch-'0', &s);// То кладём его на вершину стека (-'0' нужно сделать, потому что 
            //когда было ch = str[i] в ch положился код символа в таблице аски)
        }

        else if (ch == '*'){//Вызов МУЛЬТИПЛАЙ
            multiply(&s);
        }
        
        else if (ch == '/'){//Вызов ДИВАЙДА
            divide(&s);
        }

        else if (ch == '+'){//Вызов ЭДД
           add(&s);
        }

        else if (ch == '-'){//Вызов САБСТРУКТА
            substract(&s);
        }
    }
    
    if (s.count > 1){// Если по окончанию циклов в стеке кроме результата есть числа, то  исходная строка записана WRONG
        printf("Nevernai zapiz\n");
        return 1;
    }
    printf("%d\n", pop(&s));// Вывод на экран результат работы программы
    return 0;
}