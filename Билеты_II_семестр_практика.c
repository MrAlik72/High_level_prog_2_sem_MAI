Билеты II семестр:
                    10 билет:
1. Структуры и объединения. Передача их в функцию и возрат из функции
2. Хэш таблица
3. Реализовать функцию
Добавление в голову списка. Возвращает новое начало списка
typedef struct tlist//создание нового типа данных - структуры описаывающей односвязный список
 {
 	char *data;//указатель потому что поле данный представляет собой строку(массив)
 	struct tlist *next;//указатель на следующий элемент
 }LIST;//название нового типа данных
 LIST *list_prepend(LIST *list, const char*data){//функция возвращает указатель на новый элемент, ее аргументы - заданный список и значение поля данных
 	LIST *newnode;//создаем новый узел списка
 	newnode = (LIST*)malloc(sizeof(LIST));//выделяем под него память с помощью функций динамического выделения памяти
 	newnode->data = data;//заполняем поле данных значением из аргумента функции
 	newnode->next = NULL;//создаем нулевой указатель на следующий элемент, просто так, для безопасности, эту строчку можно не писать
 	if(newnode!=NULL){//Новый элемент был создан? Могло же не хватить памяти на компе. Проверяем это
 		newnode->next = list;//Делаем так, что голова списка у нас теперь - новый элемент, перебрасывая указатель next нового элемента на прошлую голову
 		return newnode;//возвращаем новую голову списка
 	}
 	return list;//В случае неудачи возвращаем первоначальный список(можно вернуть NULL, это на ваш вкус)
 }
                       9 билет:
1. Массивы. Объявление. Передача в функцию. Возврат массива из функции.
2. Критерии оценки сложности и эффективности алгоритма
3. Реализовать функцию
Добавление в хвост списка(см билет 10). Возвращает новый конец списка
LIST *list_addend(LIST *list, const char *data){//Название функции
	LIST *newnode;//создаем новый узел списка
	newnode = (LIST*)malloc(sizeof(LIST));//выделяем память с помощью функций динамического выделения памяти
	newnode->data = data;//заполняем поле данный значением из аргумента функции
	newnode->next = NULL;//создаем нулевой указатель на следующий элемент, просто так, для безопасности, эту строчку можно не писать
	if(newnode!=NULL){//Новый элемент был создан? Могло же не хватить памяти на компе. Проверяем это
		while(list!=NULL){//Доходим до последнего элемента в списка
			list = list->next;
		}
		list->next = newnode;//Присоединяем новый элемент к концу списка
		return newnode;//возвращаем новый конец списка
	}
	return NULL;//Если ничего не получилось, возвращаем NULL
}
                        15 билет:
1. Функции работы с памятью
2. Статические библиотеки, их создание и использование
3. Реализовать функцию:
Возвращает позицию элемента в списке при его наличии и -1 при отсутствии.
int list_position(LIST *list, LIST *el){
	int position = 0;//Позиция элемента(счетчик)
	LIST *temp;// создаем временный список, по которому будем бежать
	temp = list;//приравниваем списки
	while(temp!=NULL){//бежим по списку
		temp=temp->next;
		position++;//инкреминируем(увеличиваем на 1) позицию
		if(strcmp(list->data, el->data)==0)&& (list->next==el->next){//функция strcmp сравнивает строки и возвращаем 0, если они равны, сравниваем значние data предлагаемых в аргументах списков, сравниваем следующие элементы списка
			return position;//возвращаем позицию элемента
		}
	}
	return -1;//Если элемента в списке нет возвращаем -1
}
                         18 билет:
1. Функции работы с файлами
2. Заголовочные файлы, зачем их использовать и как. Разбиение программ на модули.
3. Бинарное дерево. Реализовать функцию добавление элемента в бинарное дерево
typedef struct betree{//Создаем новый тип данных, описывающий бинарное дерево 
	int key;
	char *value;
	struct betree *left;
	struct betree *right;
}BST;//название нового типа
void bstree_add(BST *tree, int key, char *value){
	BST *parent, *node;//создаем 2 узла - один по которому мы будем перемешаться, он станет родительским для нового узла, второй - новый создаваемый узел
	if (tree == NULL)// Если дерева вовсе и нету, сразу съебываем отсюда
	    return;
/* Отыскиваем листовой узел(узел у которого справа или слева есть указатель на NULL, куда мы и вставим узел), перемещаясь по дереву вправо или влево в зависимости от значения ключа*/
	for (parent = tree; tree != NULL; ){
		parent = tree//каждый раз мы обновляем значение parent, т.к перемещаемся
		if (key < tree->key)
			tree = tree->left;
		else if (key > tree->key)
			tree = tree->right;
		else
			return;
//Наконец-то мы добрались до конца дерева
	node = (BTS*)malloc(sizeof(BTS));//Выделяем память под новый узел
	node->key = key;//Заполняем поле ключа нового элемента ключом из аргумента функции
	node->value;//Заполняем поле знавниея элемента ключом из аргумента функции
	node->left = NULL;//формальное поле
	node->right = NULL;//формальное поле
	if(node){ //Если новая нода(листок) создалась, а вдруг нет
		if (node->key < parent->key)//Если ключ новой ноды меньше родительского, до которого мы дошли ранее 
  			parent->left = node;//ставим новую ноду влево
		else
			parent->right = node;//иначе вправо
	}
}
                            6 билет:
1. Инструмненты сборки проектов make and makefile
2. Бинарное дерево поиска
3. Реализовать функцию добавления элемента в Хэш-таблицу
#define HASHTABLESIZE 10000
struct listnode{
	char *key;
	int value;
	struct listnode *next;
};
struct listnode *hashtable[HASHTABLESIZE];//Хэш-таблица с заданным размером
int hashtable_hash(char *key);//Хэш-фукнция, преобразует ключ в чиселку
void hashtable_add(struct listnode **hashtable, char *key, int value){//наша функция добавления, ** ставится потому что указатель на хэш-таблицу будет изменяться в процессе, ее ячейки - связанные списки, поэтому они имеют тип list
	listnode *new;//Создаем новую ячейку
	int idx = hash_func(key);//idx - индекс элемента, который мы добавляем, он определяется хэш-функцией
	new = (struct listnode*)malloc(sizeof(struct listnode));//выделяем память под новый элемент таблицы
	if(new != NULL){//Проверяем выделилась ли память
		new->key = key;//устанавливаем ключ
		new->value = value;//устанавливаем значение
		new->next = hashtable[idx];//наш элемент будет новым началом односвязанного списка в ячейке, поэтому мы перебрасываем указатель next на старый элемент ячейки(который может являться списком)
		hashtable[idx] = new; //вставляем элемент в таблицу
	}

}
							5 билет:
1. Инструменты сборки проектов make and makefile
2. Библиотеки, коллекции функций, объектные файлы
3. Реализовать функцию поиска элемента в связанном списке по значению data
typedef struct tlist//все как в 9 и 10 билетах, смотри выше
 {
 	char *data;
 	struct tlist *next;
 }LIST;
 LIST *list_find(LIST *haystack, char *data){//функция, которая ищет элемент списка по data, ее возвращаемое значение LIST *(возвращаем указатель на найденный элемент или NULL)
 	while(haystack!=NULL){//Бежим по списку
 		haystack=haystack->next
 			if(strcmp(haystack->data, data)==0){//Если данные одинаковы 
 				return haystack;//Возвращаем указатель на элемент(да, именно указатель, хотя звездочки нет, она стоит в определении функции, функция сама понимает, что это указатель)
 			}
 	}
 	return NULL;
 }
 							12 билет:
1. Функции работы со строками
2. Автоматизация сборки с помощью утилиты makefile
3. Реализовать функцию подсчета длины списка
typedef struct tlist//см билеты 9, 10
 {
 	char *data;
 	struct tlist *next;
 }LIST;
 unsigned int list_legth(LIST *list){//будем возвращать чиселку(порядковый номер)
 	unsigned int count = 0;//счетчик
 	while(list!=NULL){//бежим по списку до самого конца
 		list = list->next;
 		count++;//инкеминируем(увеличиваем) счетчик
 	}
 	return count;//когда достигнули конца, возвращаем счетчик
 }
                               8 билет:
1. Перечисляемый тип enum() 
2. Структура данных стэк 
3. Бинарное дерево. Реализовать функцию поиска элемента с заданным ключом
typedef struct betree{//см выше
	int key;
	char *value;
	struct betree *left;
	struct betree *right;
}BST;
BST *bs_find_in_range(BST *tree, int key){//функция нахождения элемента по ключу
	while (tree != NULL) {//бежим по дереву
		if (key == tree->key) {//Если ключ найден, возвращаем его значение, выходим отседова
			return tree;
		} 
		else if (key < tree->key) {//Если ключ меньше, едем налево
			tree = tree->left;
		} 
		else {
			tree = tree->right;//И наконец, если больше, едем направо
		}//цикл будет повторяться до тех пор пока ключ не будет найден
		}
			return NULL;//Если ключа не оказалось в дереве, то возвращаем NULL 
}





Возможные функции:
Поиск элемента в хэш-таблице
struct listnode *hashtab_lookup(
struct listnode **hashtab,
char *key)
{
int index;
struct listnode *node;
index = hashtab_hash(key);
for (node = hashtab[index];
node != NULL; node = node->next)
{
if (strcmp(node->key, key) == 0)
return node;
}
return NULL;
}
}
Удаление элемента из хэш-таблицы:
void hashtab_delete(struct listnode **hashtab, char *key)
{
int index;
struct listnode *p, *prev = NULL;
index = hashtab_hash(key);
for (p = hashtab[index]; p != NULL; p = p->next) {
if (strcmp(p->key, key) == 0) {
if (prev == NULL)
hashtab[index] = p->next;
else
prev->next = p->next;
free(p);
return;
}
prev = p;
}
}